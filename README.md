Node_modules can be regenerated by the command (npm install) => only if they have package.json and package-lock.json files because these files contain the the packages that to be installed and their versions.


dist and parcel-cashe files can also be regenerated by the command (npx parcel index.html)

As these three files can be regenerated so these can be put under the .git-ignore file

JSX => React.createElement(object) by Babel => HTML Element (at the time of render)




// Reference
/*Headers
    logo
    NavItems
Body
    Search
    RestaurentContainer
        RestaurentCard
           Img
           Name of Restro,star rating, cuisine, delivery time
Footer
    CopyRights
    Links
    Address
    Contacts*/

#Parcel - explain in ep-02 - from the last 45 min
- Dev Build
- Local Server
- HMR Hot Module Replacement
- File Watching Algorithm written in C++
- Caching Faster Builds
- Image Optimization
- Minification
- Bundling - bundlers like webpack, parcel will bundle all our files and generate just one js file which is inside the dist folder.(but there is a problem with this one js file, ex:makemytrip websitr - here comes the concept of lazyLoading()/chinking/code splitting/dynamic loading/dynamic import/ondemand loading....etc) - and we do this in the App.js filr
- Compress
- Consistent Hashing
- Code Splitting
- Differential Bundling support older browers
- Diagnostic
- Error Handling
- HTTPS
- Tree Shaking remove unused code
- Different dev and prod bundles(more optimization on prod build and less optimization on dev build)







We push node_modules. dist and parcel-cache folders in gitignore bcoz we can regenerate them on server. Watch from 1:55:00 to 2:00:00 in ep-02 

JSX(transpiled  before it reaches the JS engine) i.e; the piece of jsx code is converted to the code that is understood by JS engine by parcel, parcel alone not doing this , it's like a manager, this parcel gives the responsibility to the package called "babel" . Refer notes for more details.


inline css - ep-04 -1:32:00


Default export/import:

export default component_name;
import export_name from ../..

Named export/import:

export const component_name
import {component_name} from ../..

#React hooks - we need to import these to use.
normal js utility functions - written by FB developers written inside the React.

Two imp React hooks:
1. useState()- this hook gives us access to super-powerfull state variable - maintains the state of the component - React doesn't detect changes made directly to variables so we use these state variables to sync UI layer with the data layer.

const [stateVariable, setStateVariable] = useState([])

to update the state variable, we use setStateVariable(updatedData),and this setStateVariable function triggers the re-rendering process and now setVariable is updated with updatted data wchich allows the UI Layer has the same data as of data layer.

whenever the state variable updates (setStateVariable()), then react re-renders the whole component with the updated or latest data.

React treats the state variable as a new state variable everytime the component re-renders. (so, that's why even though the state variable is declared using const, it's value changes upon re-rendering the component with the updated/latest data.) 

during this re-rendering the component, react goes through react-fibre algorithm, here comes the concept of virtual DOM.

Finding out diff between virtual DOMs and updating the UI is the best part of UI.

2. useEffect()

episode-7:

react-router-dom has created it's own error page which gives beautiful error handling page.But we can also create our own error page using errorElement.

RAFCE - R-React A-Arrow function F-Functional Component CE-Component with export


lazy loading === code splitting === chunking === dynamic bundling === on-demad loading  => all these one and the same 